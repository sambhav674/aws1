DevOps Lab Commands: AWS EC2, Minikube, and Nagios
1. AWS EC2 + Git + Docker Deployment

# Connect to EC2
ssh -i "mykey.pem" ubuntu@<public-ip>

# Update system
sudo apt update

# Install Docker
sudo apt-get install docker.io -y

# Install Git
sudo apt install git -y

# Install Nano
sudo apt install nano -y

# Clone GitHub Repo
git clone <github-url>
cd <repo-name>
ls

# Create Dockerfile
nano Dockerfile

# Dockerfile content:
FROM nginx
COPY index.html /usr/share/nginx/html/index.html

# Build Docker image
sudo docker build -t mywebapp .

# Run container
sudo docker run -d -p 80:80 mywebapp

# Check running containers
sudo docker ps

# Stop container
sudo docker stop <container-id>

2. Minikube Commands

# Start Minikube
minikube start

# Check Minikube status
minikube status

# Create deployment
kubectl create deployment webapp --image=nginx

# Check deployments
kubectl get deployments

# Check pods
kubectl get pods

# Expose deployment
kubectl expose deployment webapp --type=NodePort --port=80

# Check services
kubectl get svc

# Open service in browser
minikube service webapp

minikube start--driver = docker

# Delete deployment
kubectl delete deployment webapp

# Delete pod
kubectl delete pod <pod-name>

3. Nagios (Docker-based Setup)

# Pull Nagios image
docker pull jasonrivers/nagios

# Run Nagios
docker run -d --name nagios -p 9090:80 jasonrivers/nagios

# Check container
docker ps

# Stop Nagios container
docker stop nagios

# Start Nagios container
docker start nagios

# Restart container
docker restart nagios

# Remove container
docker rm -f nagios

# Access Nagios UI:
http://localhost:9090
Username: nagiosadmin
Password: nagios



pipeline {
    agent any

    stages {
        stage('Build') {
            steps {
                echo "Building the project..."
            }
        }

        stage('Deploy') {
            steps {
                echo "Deploying the project..."
            }
        }
    }
}
scripted 
node {
    
    stage('Build') {
        echo "Building the project using Scripted Pipeline..."
    }
    
    stage('Test') {
        echo "Running tests..."
    }
    
    stage('Deploy') {
        echo "Deploying the application..."
    }
}
===============================
LAB MANUAL – SOFTWARE ENGINEERING
MAVEN JAVA PROJECT + MAVEN WEB PROJECT + DOCKER
===============================

---------------------------------------
PART 1 — BUILD & PACKAGE A MAVEN JAVA APPLICATION
---------------------------------------

Step-1: Open Eclipse → File → New → Maven Project
Step-2: Select "Use default Workspace" → Next
Step-3: In the filter box type: quickstart
Step-4: Select "maven-archetype-quickstart" → Next
Step-5: Enter:
        Group Id: com.example
        Artifact Id: myapp1
        → Finish
Step-6: When console asks Y/N → type y and press Enter
Step-7: Wait until BUILD SUCCESS appears
Step-8: Open App.java and write code if needed
Step-9: Build the project:
        Right-click project → Run As → Maven Build
        Goals: clean install
        → Run
Step-10: JAR file will be created in:
         myapp1/target/myapp1-0.0.1-SNAPSHOT.jar

Step-11: Push to GitHub
         Right-click project → Show in Local Terminal (Git Bash)
         Run commands:
         git init
         git add .
         git commit -m "Maven Java Project"
         git branch -M main
         git remote add origin https://github.com/Edigirala-Neksha/se-lab-fourth
         git push -u origin main


---------------------------------------
PART 2 — CREATE A MAVEN WEB APPLICATION
---------------------------------------

Step-1: File → New → Maven Project → Next
Step-2: In filter type: webapp
Step-3: Select "maven-archetype-webapp"
Step-4: Enter Group Id + Artifact Id (ex: mywebapp) → Finish
Step-5: When console asks Y → type y and press Enter
Step-6: Wait until BUILD SUCCESS is shown

Step-7: Go to:
        src/main/webapp/index.jsp
Step-8: Replace content with:

<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<html>
<body>
<h1>Hello, this is my Maven Web Application!</h1>
</body>
</html>

Step-9: Save the file (Ctrl + S)

Step-10: Build the project:
         Right-click project → Run As → Maven Build
         Goals: clean install
         → Run

Step-11: WAR file will be created at:
         mywebapp/target/mywebapp.war

Step-12: Push the web project to GitHub:
         git add .
         git commit -m "Maven Web Project"
         git push origin main


---------------------------------------
PART 3 — RUN MAVEN WEB PROJECT ON SERVER
---------------------------------------

Step-1: Right-click project → Run As → Run on Server
Step-2: Select Apache Tomcat → Next
Step-3: Add the project to the server → Finish
Step-4: Browser will display:
        "Hello, this is my Maven Web Application!"


---------------------------------------
PART 4 — DOCKER INSTALLATION + BASIC COMMANDS
---------------------------------------

Installing Docker:
(Use Docker Desktop for Windows)

Basic Docker CLI Commands:

1. Check Docker version:
   docker --version

2. Pull Nginx image:
   docker pull nginx

3. Run Nginx container:
   docker run -d -p 8080:80 --name mynginx nginx

4. Check running containers:
   docker ps

5. Stop container:
   docker stop mynginx

6. Start container:
   docker start mynginx

7. Remove container:
   docker rm mynginx

8. Remove image:
   docker rmi nginx

---------------------------------------
END OF LAB STEPS
---------------------------------------
JENKINS EMAIL CONFIGURATION + MAVEN PROJECT POST-BUILD EMAIL SETUP
PART 1 — GENERATE GMAIL APP PASSWORD
1. Go to: https://myaccount.google.com/security
2. Enable 2-Step Verification.
3. After enabling, open: https://myaccount.google.com/apppasswords
4. Select:
App: Mail
Device: Other (Custom) → enter Jenkins
5. Click Generate.
6. Copy the 16-digit App Password.
PART 2 — CONFIGURE EMAIL IN JENKINS (GLOBAL SETTINGS)
Open Jenkins:
Manage Jenkins → Configure System
A) E-mail Notification Section
SMTP server: smtp.gmail.com
Use SMTP Authentication: Yes
Username: your Gmail
Password: Gmail App Password
Use SSL: Yes
SMTP Port: 465
B) Extended E-mail Notification Section
SMTP server: smtp.gmail.com
Default user e-mail suffix: @gmail.com
Use SMTP Authentication: Yes
Username: your Gmail
Password: Gmail App Password
Use SSL: Yes
SMTP Port: 465
Save the configuration.
PART 3 — MAVEN PROJECT POST-BUILD EMAIL
Open Maven Job → Configure
Add post-build action → Editable Email Notification
Fill:
Project Recipient List: your Gmail
Reply-To List: your Gmail
Content Type: text/plain
Default Subject: Build ${BUILD_STATUS}: ${JOB_NAME} #${BUILD_NUMBER}
Default Content:
Job Name: ${JOB_NAME}
Build Number: ${BUILD_NUMBER}
Build Status: ${BUILD_STATUS}
Console Output: ${BUILD_URL}
Attach Build Log: Yes
Add Trigger → Failure
PART 4 — SAVE & TEST
Save → Build Now
If build fails → Email should arrive.


GIT MASTER COMMAND LIST

1. Configure Git
git config --global user.name "Your Name"
git config --global user.email "email@example.com"
git config --list

2. Initialize Repository
git init

3. Check Status
git status

4. Add Files
git add .
git add filename.txt

5. Commit Changes
git commit -m "Your commit message"

6. Connect to GitHub
git remote add origin <repo-url>
git remote -v
git remote remove origin

7. Push to GitHub
git push -u origin main
git push
git push --force

8. Pull from GitHub
git pull
git pull origin main --allow-unrelated-histories

9. Clone Repository
git clone <repo-url>

10. Branch Operations
git branch
git branch feature-1
git checkout -b feature-1
git checkout main
git branch -d feature-1
git branch -D feature-1

11. Push Branch
git push -u origin feature-1

12. Merge Branch
git checkout main
git merge feature-1

13. Commit History
git log
git log --oneline
git log --oneline --graph --decorate --all

14. Diff
git diff
git diff --staged

15. Remove & Restore
git rm filename.txt
git commit -m "Removed file"
git restore filename.txt
git restore --staged filename.txt

16. Reset / Undo
git reset --soft HEAD~1
git reset --hard HEAD~1
git reset HEAD filename.txt

17. Fork & Upstream Workflow
git remote add upstream <original-repo-url>
git fetch upstream
git merge upstream/main

TASK 3 – COLLABORATIVE CODING USING GIT
(All commands needed for cloning, branching, feature workflow, forking, PR creation)

----------------------------------------------------------
A. ORGANIZATION / PRIVATE REPOSITORY COLLAB WORK
----------------------------------------------------------

# Clone private repo
git clone <org-repo-url>
cd <repo-folder>

# Check remote
git remote -v

# Create new branch
git branch feature-01
git checkout feature-01
# OR
git checkout -b feature-01

# Create / modify files
# (example)
# notepad file.txt  -> Windows

# Stage changes
git add .
git add filename.txt

# Commit changes
git commit -m "Added new feature file"

# Push feature branch
git push -u origin feature-01

# Create Pull Request on GitHub UI
# (No command needed)

----------------------------------------------------------
B. FORK WORKFLOW COMMANDS (simple-repo-se)
----------------------------------------------------------

# Fork repo from GitHub UI

# Clone your fork
git clone <your-fork-url>
cd <repo-folder>

# Verify remote
git remote -v

# Add upstream (original repo)
git remote add upstream <original-repo-url>

# Fetch upstream changes
git fetch upstream

# Merge upstream into main
git checkout main
git merge upstream/main

# Create a feature branch
git checkout -b feature-readme

# Modify README.md
# notepad README.md

# Stage + commit
git add README.md
git commit -m "Updated README.md with new content"

# Push to your fork
git push -u origin feature-readme

# Create Pull Request back to ORIGINAL repo

----------------------------------------------------------
C. COMMON COLLABORATION COMMANDS
----------------------------------------------------------

# Check status
git status

# List branches
git branch

# Switch branches
git checkout main
git checkout feature-01

# Delete branch
git branch -d feature-01
git branch -D feature-01

# Pull latest updates
git pull

# Merge branches locally
git checkout main
git merge feature-01

# View commit history
git log
git log --oneline
git log --oneline --graph --decorate --all

# Undo commit but keep changes
git reset --soft HEAD~1

# Undo commit and delete changes
git reset --hard HEAD~1

# Unstage a file
git reset HEAD filename.txt

### Book Bank System: Functional and Non-Functional Requirements

#### **1. Functional Requirements**

Functional requirements describe the specific functions and features that the system should support. For the **Book Bank System**, these can be broken down as follows:

**A. User Registration and Authentication**

* The system should allow users (students, faculty, staff) to create accounts and log in using a unique ID and password.
* Authentication should include verifying credentials and providing role-based access (Student, Librarian, Admin).

**B. Book Catalog Management**

* The system must allow the admin to add, update, and delete book details (title, author, ISBN, quantity).
* The catalog should display books that are available in the library, including details such as availability status, author name, and genre.

**C. Borrowing and Returning Books**

* Registered users (students, staff, faculty) should be able to search and borrow books.
* The system should record the borrowing date and due date for returning the books.
* Users should be able to return the books and update the system with the return date.
* The system should check book availability before allowing the user to borrow it.

**D. Book Reservation**

* Users should be able to reserve books that are currently unavailable and be notified when they are available.

**E. Notifications**

* The system should notify users about overdue books or upcoming due dates through email or SMS.

**F. Fine Management**

* The system should calculate fines for overdue books based on the number of days past due.
* It should allow users to view and pay fines.

**G. Search Functionality**

* Users should be able to search the book catalog based on various criteria such as book title, author, genre, or ISBN.

**H. Reports and Analytics (Admin)**

* Admins should be able to generate reports such as book borrow history, fines, and available books.

#### **2. Non-Functional Requirements**

Non-functional requirements define the quality attributes, system performance, and constraints that the system should meet.

**A. Performance**

* The system should be able to handle a high volume of users simultaneously, especially during peak hours like exam periods.
* Response time for searching books and checking availability should be under 2 seconds.

**B. Scalability**

* The system should be scalable to accommodate a growing number of users and books over time.

**C. Availability**

* The system should be available 24/7 with minimal downtime, ensuring continuous access to book-related services.

**D. Security**

* The system must implement secure login mechanisms (e.g., encryption of passwords, HTTPS).
* Users should only have access to data relevant to their roles (e.g., students shouldn't be able to modify the book catalog).

**E. Usability**

* The interface should be intuitive and user-friendly, allowing users to quickly find books, borrow, and return them.
* The system should provide help and support in case of issues.

**F. Backup and Recovery**

* The system should periodically back up data to prevent data loss.
* It should include a disaster recovery plan to restore the system in case of failures.

**G. Compliance**

* The system should comply with relevant standards and regulations such as data protection laws.

---

### **Sequence Diagram for Book Bank System (in UML)**

Now, let's create a **sequence diagram** to represent the flow of operations for borrowing a book in the Book Bank System.

Here are the main **actors** and **objects** involved:

* **Actor:** User (Student, Faculty, Staff)
* **Actor:** Admin (for catalog management)
* **Objects:** System, Book Catalog, Notification Service, Fine System

#### **Use Case: Borrowing a Book**

1. **User** logs in to the system.
2. The **System** validates the credentials.
3. The **User** searches for the desired book from the **Book Catalog**.
4. The **System** checks the availability of the book.

   * If the book is available:

     * The **User** requests to borrow the book.
     * The **System** updates the book status to "borrowed" and records the borrowing date.
     * The **System** assigns a due date.
     * The **System** sends a notification to the **User** about the borrowing and due date.
5. If the book is unavailable:

   * The **System** informs the **User** and asks if they would like to reserve the book.
   * If the **User** opts to reserve the book, the **System** updates the reservation list.

#### **Sequence Diagram**

Below is the textual representation of the sequence diagram for borrowing a book:

```plaintext
Participant: User
Participant: System
Participant: Book Catalog
Participant: Notification Service
Participant: Fine System

User -> System: Login request
System -> System: Validate credentials
System -> User: Login success/failure

User -> Book Catalog: Search for book
Book Catalog -> System: Check availability

alt Book available
    System -> Book Catalog: Reserve book (borrow)
    Book Catalog -> System: Update status to borrowed
    System -> Fine System: Record borrowing date, due date
    System -> Notification Service: Send notification (due date)
    Notification Service -> User: Notify borrowing info (due date)
else Book unavailable
    System -> User: Book not available
    User -> System: Reserve book request
    System -> Book Catalog: Reserve book
    Book Catalog -> System: Update reservation status
end
```

#### **Explanation:**

* The **User** logs in to the **System**.
* After successful login, the **User** searches for a book from the **Book Catalog**.
* The **System** checks if the book is available.
* If the book is available, the **System** updates the book’s status and sends a notification to the **User**.
* If the book is unavailable, the **System** allows the **User** to reserve it.

This is just one of many scenarios in the system. You can create similar sequence diagrams for other actions like returning a book, paying fines, or generating reports.

Let me know if you need more detail or further modifications!



----------------------------------------------------------
END OF TASK 3 COMMAND SET
----------------------------------------------------------

